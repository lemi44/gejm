#ifndef PHYSICS_H
#define PHYSICS_H

#include "Creature.h"
#include <list>
#include <SDL_timer.h>

/**
 * State is a struct that holds current state of position and velocity.
 */
struct State
{
	double x;      // position
	double v;      // velocity
};

/**
 * Derivative is a struct that holds current derivative of position and velocity.
 */
struct Derivative
{
	double dx;      // dx/dt = velocity
	double dv;      // dv/dt = acceleration
};

/**
 * Physics is a class that is responsible for simulating physics.
 */
class Physics
{
public:
    /**
     * Default constructor of Physics.
     * Sets currentTime, t, dt, accumulator and boundaries of physical simulation.
     * @param boundaryWidth width of bounding box in which physical simulation is simulated
     * @param boundaryHeight height of bounding box in which physical simulation is simulated
     */
	Physics(int boundaryWidth, int boundaryHeight);

    /**
     * Copy constructor is deleted because it shouldn't be ever used.
     */
	Physics(Physics const&) = delete;
	
    /**
     * Default destructor.
     */
    ~Physics();
	
    /**
     * Calculate next steps of simulation.
     * @param objectList reference to a list of all game objects
     * @return double because physical simulation is calculated in fixed steps, function returns coefficient of game state between steps, where 0 is previous step and 1 is current step
     */
    double update(std::list<Object*>& objectList);

    /**
     * Assigment operator is overloaded because it cannot be generated by compiler but because it shouldn't be used it's deleted.
     */
    Physics& operator=(Physics const&) = delete; 
	
private:
    /**
     * Current discrete time of simulation.
     */
	double t;
	
    /**
     * Timestep of simulation.
     */
    const double dt;
	
    /**
     * Current time of game.
     */
    double currentTime;

    /**
     * Time of simulation still to be processed.
     */
	double accumulator;

    /**
     * Width of bounding box by which simulation is constrained.
     */
    int boundaryWidth;
    
    /**
     * Height of bounding box by which simulation is constrained.
     */
    int boundaryHeight;

    /**
     * An RK4 integrator used to calculate next State based on current State.
     * @param state reference to state that will be changed
     * @param t current point in discrete time
     * @param dt a timestep
     * @param isY if false gravity won't be added into calculation, otherwise it will be
     * @return void
     */
	void integrate(State& state, double t, double dt, bool isY);
	
    /**
     * Calculate a derivative of initial state in discrete time.
     * @param state Reference to state that will be changed
     * @param t current point in discrete time
     * @param dt a timestep
     * @param d a derivative by which state should be changed in time
     * @param isY if false gravity won't be added into calculation, otherwise it will be
     * @return Derivative new derivative after calculations
     */
    Derivative evaluate(State const& initial, double t, double dt, Derivative const& d, bool isY);

    /**
     * Calculate acceleration by applying spring and damper forces.
     * Currently is changed to return constant 9.81 which is Earth's gravitational acceleration.
     * @param state reference to state that is used in calculations
     * @param t current point in discrete time
     * @return double used to be calculated spring and damper forces. Now always constant 9.81
     */
	double acceleration(const State &state, double t);

    /**
     * Performs check on Axis-Aligned Bounding Boxes if they collide and calls proper collision resolving functions.
     * @param objectList reference to a list of all game objects
     * @return void
     */
	void checkCollision(std::list<Object*>& objectList);
};

#endif // PHYSICS_H